#+HTML:<div align=center><a href="https://github.com/p3r7/awesome-elisp"><img alt="Emacs Logo" width="240" height="240" src="https://upload.wikimedia.org/wikipedia/commons/0/08/EmacsIcon.svg"></a>

* Awesome Elisp

#+HTML:</div>

Welcome to /Awesome Elisp/, a list of resources linked to Emacs LISP (elisp) development.

It's aim is to not be a simple index but a /compendium/: resources are not only listed but also commented.

It tries to be as exhaustive as possible.

For a more general index related to all-things Emacs, use [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs]].


* Table of Contents                                                     :TOC_5:QUOTE:
#+BEGIN_QUOTE
- [[#resources][Resources]]
  - [[#entry-level][Entry-level]]
  - [[#advanced][Advanced]]
  - [[#cookbooks][Cookbooks]]
- [[#libraries][Libraries]]
  - [[#core--general-purpose][Core / General Purpose]]
  - [[#data-structures][Data Structures]]
    - [[#strings][Strings]]
    - [[#sequences][Sequences]]
    - [[#maps][Maps]]
    - [[#custom-types--oop][Custom Types & OOP]]
    - [[#date--time][Date & Time]]
    - [[#tables][Tables]]
    - [[#queues][Queues]]
    - [[#trees][Trees]]
    - [[#parsers--parse-trees][Parsers & Parse Trees]]
    - [[#xmlhtml][XML/HTML]]
    - [[#org-mode-outlines][Org-mode outlines]]
    - [[#color-codes][Color Codes]]
  - [[#concurrency--asynchronicity][Concurrency / Asynchronicity]]
    - [[#timers][Timers]]
    - [[#promises][Promises]]
    - [[#async-elisp-function-calls][Async elisp function calls]]
    - [[#async-sub-processes][Async sub-processes]]
    - [[#async-interpreter-command-sub-processes][Async interpreter command sub-processes]]
  - [[#buffer-manipulation][Buffer Manipulation]]
  - [[#filesystem-interactions][Filesystem Interactions]]
  - [[#networking][Networking]]
    - [[#http-client][HTTP client]]
    - [[#http-server][HTTP server]]
  - [[#gui][GUI]]
    - [[#popups][Popups]]
    - [[#overlays][Overlays]]
    - [[#charts--diagrams][Charts & diagrams]]
- [[#development-tools][Development Tools]]
  - [[#interactive-development--debugging][Interactive Development & Debugging]]
  - [[#documentation][Documentation]]
  - [[#code-navigation][Code Navigation]]
  - [[#validation][Validation]]
  - [[#syntax-highlighting][Syntax highlighting]]
  - [[#pretty-printing][Pretty printing]]
  - [[#building][Building]]
- [[#heroes][Heroes]]
- [[#license][License]]
#+END_QUOTE


* Resources

** Entry-level

*** An Introduction to Programming in Emacs Lisp

    [[https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html][read online]]

    Also comes bundled with Emacs.
    Just =C-h i= (or =M-x info=) and open =Emacs Lisp Intro=.

    A bit scholarly. Not the easiest read.


*** Emacs In A Box - Elisp Programming

    [[http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Programming.html][read online]], [[https://github.com/caiorss/Emacs-Elisp-Programming/blob/master/Elisp_Programming.org][source]]

    Very complete and gentle introduction.


*** (Almost) All You Need to Know About Variables

    [[https://with-emacs.com/posts/tutorials/almost-all-you-need-to-know-about-variables/][read online]]

    A must read!


*** elisp-guide

    [[https://github.com/chrisdone/elisp-guide][read online]]

    Focused on introducing general concepts and terminology.


*** Emergency Elisp

    [[http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html][read online]]

    Focused around data structures.
    More like a cheat sheet.


*** ElispCheatSheet

    [[https://alhassy.github.io/ElispCheatSheet/][read online]], [[https://github.com/alhassy/ElispCheatSheet][source]]

    Focused around data structures.
    Author's Common Lisp background can be felt.


** Advanced

*** Emacs Lisp Reference Manual

    [[https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html][read online]]

    Also comes bundled with Emacs.
    Just =C-h i= (or =M-x info=) and open =Elisp=.

    Comprehensive guide of core elisp APIs.

    Generally well written but needs you to understand its logic and be familiar with Emacs terminology.


*** The Emacs Lisp Style Guide

    [[https://github.com/bbatsov/emacs-lisp-style-guide][read online]]

    Provides solid guidelines on the dos and don'ts for quality elisp code.


*** The Emacs Package Developer’s Handbook

    [[https://alphapapa.github.io/emacs-package-dev-handbook/][read online]], [[https://github.com/alphapapa/emacs-package-dev-handbook][source]]

    List bunch of tools and libraries for helping package developers.
    Also provides various snippets and best practices.
    Lots of good insights, but its structure is kinda off-putting.


** Cookbooks

*** elisp-demos

    [[https://github.com/xuchunyang/elisp-demos/blob/master/elisp-demos.org][read online]], [[https://github.com/xuchunyang/elisp-demos][source]]

    Very good and beginner-friendly.

    Almost complete list of single-liner examples of standard function.
    Also packs examples fro =dash= and =s=.


*** Emacs In A Box - Elisp Snippets

    [[http://caiorss.github.io/Emacs-Elisp-Programming/Elisp_Snippets.html][read online]], [[https://github.com/caiorss/Emacs-Elisp-Programming/blob/master/Elisp_Snippets.org][source]]

    Really nice selection of snippets with real-world use-cases.


*** EmacsWiki's Cookbook

    [[https://www.emacswiki.org/emacs/ElispCookbook][read online]]

    Community-driven snippets, beginner-friendly.


*** @alphapapa's unpackaged.el

    [[https://alphapapa.github.io/unpackaged.el/][read online]], [[https://github.com/alphapapa/unpackaged.el][source]]

    Real-world selection of snippets, not beginner-friendly.


* Libraries

  Traditionally, it was recommended to not use external libs/dependencies and prefer using standard APIs bundled with Emacs.

  These recommendation are still mostly valid but predated the advent of =package.el=.

  Some external libs are now considered "standard", as lots of popular packages use them and they can outperform standard implementations while still being simpler to use (e.g. =dash=).

  Some libraries might be listed several times, as they fit in several categories (e.g. =subr-x=, =dash=).


** Core / General Purpose

**** cl-lib

     *standard* (bundled with every Emacs install)

     Lib extending elisp with functionalities inherited from Common Lisp.

     Just do a =(require 'cl-lib)= to use it.


**** subr-x

     [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/subr-x.el][source]]

     *standard* (bundled with every Emacs install)

     Intended as an extension to [[https://github.com/emacs-mirror/emacs/blob/master/lisp/subr.el][subr.el]], the core library of basic functions written in elisp.

     Provides:
     - threading macros (/a la/ Clojure, =thread-first= and =thread-last=)
     - additional binding helpers (=if-let=, =if-let*=, =when-let=, =when-let*= and =and-let*=)    - hash-table manipulation helper (=hash-table-empty-p=, =hash-table-keys= and =hash-table-values=)
     - string manipulation helper (=string-empty-p=, =string-blank-p=, =string-join=, =string-trim=, =string-trim-left=, =string-trim-right=, =string-remove-prefix= and =string-remove-suffix=)
     - region manipulation helpers (=replace-region-contents=)


**** dash

     [[https://github.com/magnars/dash.el][source & doc]]

     *informal standard* (not bundled with Emacs, but used everywhere)

     Even though this lib revolves primarily around list manipulation, it also offers for general purpose utils.

     Those are:
     - [[https://github.com/magnars/dash.el#threading-macros][threading macros]]
     - [[https://github.com/magnars/dash.el#function-combinators][function combinators]]
     - [[https://github.com/magnars/dash.el#binding][additional binding helpers]]

     They all seem to be heavily inspired by Clojure.


**** el-patch

     [[https://github.com/raxod502/el-patch][source and doc]]

     More perene advices, get notified when they break.


**** anaphora

     [[https://github.com/rolandwalker/anaphora][source & doc]]

     Allows the definition of anaphoric functions (as can be found in Common Lisp, Clojure...).


**** with-simulated-input

     [[https://github.com/DarwinAwardWinner/with-simulated-input][source & doc]]

     *informal standard* (not bundled with Emacs, but used everywhere)

     Simulate interactive user interactions.

     Mostly usefull for writing tests.


**** signal

     [[https://github.com/Mola-T/signal][source & doc]]

     Reimplementation of hooks, with more advanced features.


**** weak-ref

     [[https://github.com/skeeto/elisp-weak-ref][source & doc]]

     Allows creating weak reference to vars.
     Weak reference offer better performance but can be garbage collected.


**** fn

     [[https://github.com/troyp/fn.el][source & doc]]

     Provides macros for a more concise lambda syntax, /a la/ Clojure.


** Data Structures

*** Strings

**** subr-x

     [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/subr-x.el][source]]

     *standard* (bundled with every Emacs install)

     Provide the following helpers: =string-empty-p=, =string-blank-p=, =string-join=, =string-trim=, =string-trim-left=, =string-trim-right=, =string-remove-prefix= and =string-remove-suffix=.


**** s

     [[https://github.com/magnars/s.el][source & doc]]

     *informal standard* (not bundled with Emacs, but used everywhere)

     Advanced yet easy to use string manipulation helpers.


**** rx

     [[https://francismurillo.github.io/2017-03-30-Exploring-Emacs-rx-Macro/][tutorial]]

     *standard* (bundled with every Emacs install)

     Macro for helping writing elisp regexp.


*** Sequences

**** seq

     [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/seq.el][source]], [[https://github.com/NicolasPetton/seq.el][doc]]

     *standard* (bundled with every Emacs install, since version 25)


**** dash

     [[https://github.com/magnars/dash.el][source & doc]]

     *informal standard* (not bundled with Emacs, but used everywhere)

     Advanced yet easy to use list manipulation helpers.
     Lots of them also have alternative anaphoric forms.


**** stream

     [[https://github.com/NicolasPetton/stream][source & doc]]

     Allows defining streams of data as data sequences.
     Compatible w/ seq.el.


**** trie

     [[http://www.dr-qubit.org/predictive/trie.el][source]]

     Provides APIs for building and manipulating /tries/, sequence-like data structures where both storage and retrieval are space- and time-efficient.

     Stored elements must be ordered sequences, i.e. strings (most common use-case), lists or vectors.


*** Maps

    (Hash)maps are a special type of sequences that allow representing a list of key / value pairs.
    In other languages they can also be called associative arrays or dictionaries.

    In elisp, a map can be represented as:
    - an [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][alist]] (association list, preserving element order)
    - a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Property-Lists.html][plist]] (property list, more human-readable)
    - an [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Hash-Tables.html][hash-table]]

    | data structure | human-readability | insert speed | lookup speed         | ordered? |
    |----------------+-------------------+--------------+----------------------+----------|
    | alist          | meh               | fastest      | slower as data grows | yes      |
    | plist          | very good         | ok           | fast                 | no       |
    | hash-table     | ok                | ok           | very fast            | no       |


    The official doc also has [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Plists-and-Alists.html][a nice section comparing plists and alists]].

    tl;dr:
    - planning on doing lots of inserts and a few lookups (or mostly on recent elements), use an alist
    - planning on having a big number of elements and lookup speed is critical, use an hash-map
    - every other case: use a plist

    Older Emacs packages tend to rely mostly on alists, sometimes for no good reason.

    Each data structure has its own APIs to get/insert/update.

    Thankfully, some libraries provide an abstraction layer that allows having a single API for multiple data structures.

    I would recommend sticking with thee default =map.el= library, unless you really enjoy the Clojure syntax in which case =a.el= is also a nice choice.
    If you know for sure that you want to stick with an alist or a hash-table or  =asoc.el= and =ht= are high quality choice.


**** map

     [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/map.el][source]]

     *standard* (bundled with every Emacs install, since version 25)

     supports: alists, plists and hash-tables.

     Shared API for all 3 elisp map objects.
     Weirdly enough, plists are called "arrays" in its source/inline docs.

     No documentation other than what is inlined in source.


**** asoc

     [[https://github.com/troyp/asoc.el][source & doc]]

     *informal standard* (not bundled with Emacs, but used everywhere)

     supports: only alists.

     Nice set of additional APIs for alists.


**** ht

     [[https://github.com/Wilfred/ht.el][source & doc]]

     *informal standard* (not bundled with Emacs, but used everywhere)

     supports: only hash-tables, but allow converting from/to alists and plists.

     Nice set of additional APIs for hash-tables.


**** a

     [[https://github.com/plexus/a.el][source & doc]]

     supports: alists and hash-tables.

     Shared API for alists and hash-tables.
     Like =map.el=, but in a more "Clojurey" syntax.


**** kv

     [[https://github.com/nicferrier/emacs-kv][source & doc]]

     support: mostly alists, but allow converting from/to alists and plists.


**** dict-tree

     [[http://www.dr-qubit.org/predictive/dict-tree.el][source]]

     Provides APIs for building and manipulating /Dictionary trees/, hybrid between [[#trie][tries]] and hash tables.

     Think about it as a more storage-efficient hash tables.


*** Custom Types & OOP

    Can be done natively using [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Records.html#Records][records]], additional custom user-defined types.

**** cl-lib (defstruct API)

     [[https://www.gnu.org/software/emacs/manual/html_node/cl/Structures.html][API documentation]]

     *standard* (bundled with every Emacs install)

     One part of =cl-lib= is APIs to define and manipulate C-like data structures, strongly typed.

     Provides the =cl-defstruct= macro.

     Built on top of the native [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Records.html#Records][records]] system.

     See also this blog post from @skeeto: [[https://nullprogram.com/blog/2018/02/14/][Options for Structured Data in Emacs Lisp]]


**** EIEIO

     [[https://www.gnu.org/software/emacs/manual/html_mono/eieio.html][doc]]

     *standard* (bundled with every Emacs install)

     Stands for /Enhanced Implementation of Emacs Interpreted Objects/.

     Brings an OOP layer to elisp, based upon the /Common Lisp Object System/ (CLOS).

     Provides the =defclass= macro.

     Built on top of the native [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Records.html#Records][records]] system.


*** Date & Time

**** ts

     [[https://github.com/alphapapa/ts.el][source & doc]]

     *informal standard* (not bundled with Emacs, but used everywhere)

     Advanced yet easy to use datetiem / timestamp library.


**** datetime

     [[https://github.com/doublep/datetime][source & doc]]

     Library for parsing, formatting, matching and recoding timestamps and date-time format strings.


**** datetime-format

     [[https://github.com/emacs-php/emacs-datetime][source & doc]]

     Provides =datetime-format=, inspired by PHP’s =Datetime::format= method.


*** Tables

**** tabulated-list

     *standard* (bundled with every Emacs install)

     Library for defining, manipulating and displaying tables.


**** tablist

     [[https://github.com/politza/tablist][source & doc]]

     *informal standard* (not bundled with Emacs, but used everywhere)

     Extension to tabulated-list, adding possibility to mark and filter items.


**** navigel

     [[https://github.com/DamienCassou/navigel][source]]

     Facilitate the creation of =tabulated-list=-based UIs.

     Also relies on =tablist=.


**** cell

     [[http://xelf.me/cell.html][doc]], [[https://gitlab.com/dto/mosaic-el/blob/master/cell.el][source]]

     Provides =cell-mode=, major mode for building spreadsheet-based user-interfaces.


**** ctable

     [[https://github.com/kiwanami/emacs-ctable][source & doc]]

     Library for defining, manipulating and displaying tables.


*** Queues

**** queue

     [[http://www.dr-qubit.org/predictive/queue.el][source]]

     *standard* (bundled with every Emacs install)

     Provides FIFO / FILO queue APIs.


**** fifo-class

     [[https://github.com/mola-T/fifo-class][source & doc]]

     An EIEIO abstract class class to provide FIFO methods to /[[https://www.gnu.org/software/emacs/manual/html_node/eieio/Slot-Options.html][slots]]/.


*** Trees

**** heap

     [[http://www.dr-qubit.org/predictive/heap.el][source]]

     Provides APIs to build and manipulate a /ternary/ (at most 3 children per node) /heap/ (self-sorting tree).


**** avl-tree

     [[http://www.dr-qubit.org/predictive/avl-tree.el][source]]

     *standard* (bundled with every Emacs install)

     Provides APIs to build and manipulate a self-balancing binary tree.


**** hierarchy

     [[https://github.com/DamienCassou/hierarchy][source & doc]], [[https://emacs.cafe/emacs/guest-post/2017/06/26/hierarchy.html][blog post]]

     Allows defining trees as well as displaying them.


**** treepy

     [[https://github.com/volrath/treepy.el][source & doc]]

     Allows defining and traversing trees.


**** rbit

     [[http://elpa.gnu.org/packages/rbit.html][source]]

     Self-balancing interval trees.

     Implementation of Chris Okasaki's algorithm from [[https://dl.acm.org/citation.cfm?id=968578.968583&coll=DL&dl=GUIDE]["Red-black trees in a functional setting", JFP'99]].


*** Parsers & Parse Trees

    Those libraries allow parsing a document in a format / language and converting it to an tree, called an an [[https://en.wikipedia.org/wiki/Abstract_syntax_tree][AST]].


**** parse-it

     [[https://github.com/jcs-elpa/parse-it][source & doc]]

     Regexp-based parser, supporting a bunch of languages.


**** tree-sitter

     [[https://github.com/ubolonton/emacs-tree-sitter/][source & doc]], [[https://www.reddit.com/r/emacs/comments/chnxzm/dynamic_module_binding_for_treesitter_an/][reddit post]]

     Implemented as a module, binding with the [[https://tree-sitter.github.io/tree-sitter/][tree-sitter]] parser (written in Rust).


**** tNFA

     [[http://www.dr-qubit.org/predictive/tNFA.el][source]]

     Provides APIs to build and manipulate NFA (/Nondeterministic Finite Automaton/), i.e. a state machine / decision tree.

     It was built manily with regexp parsing in mind.


**** parsec

     [[https://github.com/cute-jumper/parsec.el][source & doc]]

     Parsing library in the spirit of Haskell's parsec.


**** pl

     [[https://github.com/jwiegley/emacs-pl][source & doc]]

     Parsing library in the spirit of Haskell's parsec. Somewhat limited.


*** XML/HTML

**** dom

     *standard* (bundled with every Emacs install)

     DOM manipulation and searching functions.


**** xml-query

     [[https://github.com/skeeto/elfeed/blob/master/xml-query.el][source]]

     List-based XML selectors. Part of the elfeed package.


*** Org-mode outlines

    =org-mode= outlines can be considered both a file format and a tree format.
    =org-element.el= implements the parser used by =org-mode= to convert a text buffer into a tree structure (/parse-tree/).


**** org-ml

     [[https://github.com/ndwarshuis/org-ml][source & doc]]

     Functional manipulation of an org parse-tree.


**** org-ql

     [[https://github.com/alphapapa/org-ql][source & doc]]

     Query language ([[https://en.wikipedia.org/wiki/Domain-specific_language][DSL]]) for parsing, searching and filtering an org outline.

**** org-ba

     [[https://github.com/Fuco1/orgba][source & doc]]

     More user-friendly APIs for writting code for interacting with org documents.


*** Color Codes

**** yk-color

     [[https://github.com/yurikhan/yk-color][source]]

     Color codes manipulation.


** Concurrency / Asynchronicity

   Concurrency in elisp / Emacs is a hot topic.

   Due to its single-threaded nature, we can't do parallel processing unless using some dirty tricks (see [[#async][async]]).

   But that doesn't prevent us from doing concurrent processing, with say /timers/.

   Emacs recently extended this support with [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Generators.html][generators]] (since 25.1) [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html][native threads]] (not what you might be thinking of, since 26.1).

   For more info on those subject, read:
   - [[https://www.emacswiki.org/emacs/NoThreading][emacswiki/No Threading]]
   - [[https://www.emacswiki.org/emacs/NoThreading][emacswiki/Concurrent Emacs]]
   - blog post from @skeeto: [[https://nullprogram.com/blog/2018/05/31/][Emacs 26 Brings Generators and Threads]]


*** Timers

**** timer.el

     [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/timer.el][source]]

     Default timer lib.


**** named-timer

     [[https://github.com/DarwinAwardWinner/emacs-named-timer][source & doc]]

     Easier to use timer lib.


*** Promises & Delays

**** thunk.el

     [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/thunk.el][source]]

     *standard* (bundled with every Emacs install)

     Provides an API for creating and dereferencing / evaluating /delays/.


**** promise.el

     [[https://github.com/chuntaro/emacs-promise][source & doc]]

     Reimplementation of the [[https://promisesaplus.com/][Promises/A+]] open standard (originally targeting Javascript).


**** aio

     [[https://github.com/skeeto/emacs-aio][source & doc]], [[https://nullprogram.com/blog/2019/03/10/][blog post]]

     Mostly an async/await lib but implements its own promise system internally.


*** Async elisp function calls

**** deferred

     [[https://github.com/kiwanami/emacs-deferred][source & doc]]

     Not super-actively maintained, but featureful.

     Achieves concurrency through the use of timers.

     Also allows handling async (sub-)processes and HTTP calls with [[https://github.com/tkf/emacs-request][request.el bindings]].


**** async

     [[https://github.com/jwiegley/emacs-async][source & doc]]

     *informal standard* (not bundled with Emacs, but used everywhere)

     Achieves true parallel processing by spawning a child Emacs sub-process.
     As such, necessary context needs to be passed w/ =async-inject-variables=.

     Supports defining callbacks.

     Offers bindings w/ =dired=, =bytecomp= and =smtp-mail=.


**** timp

     [[https://github.com/mola-T/timp][source & doc]]

     Multithreading through sub-processes with over-the-wire payload capabilities.

     Achieves true parallel processing by spawning a child Emacs sub-process.


**** aio

     [[https://github.com/skeeto/emacs-aio][source & doc]], [[https://nullprogram.com/blog/2019/03/10/][blog post]]

     Short for =async-io=.

     Allows writing coroutines with the async/await syntax found in Python's [[https://docs.python.org/3/library/asyncio.html][asyncio]].

     Internal representation relies on its own promise implementation and [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Generators.html][generators]].


**** async-await

     [[https://github.com/chuntaro/emacs-async-await][source & doc]]

     Simple implementation of Async/Await, based on the TypeScript syntax.

     Relies on =promise.el= and [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Generators.html][generators]]..


**** lcr

     [[https://github.com/jyp/lcr][source]]

     lcr stands for Lightweight CoRoutines.

     Seems to rely on timers.


*** Async sub-processes

    These libs only allow to run asynchronously command processes (as opposed to elisp function calls).

    It can be done in standard with low-level function =make-process= or derivatives =start-process=, =make-pipe-process= and =start-process-shell-command=.

    Some advanced behaviours are hard to program, that's why wrapper libraries can help you.

    Notably:
    - ensuring the process is launched asynchronously (not blocking Emacs)
    - configuring callbacks (by binding a [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Sentinels.html][sentinel]] to the process)


**** deferred

     [[https://github.com/kiwanami/emacs-deferred][source & doc]]

     Not super-actively maintained, but featureful.

     Also allows handling async elisp function calls and HTTP calls with [[https://github.com/tkf/emacs-request][request.el bindings]].


**** bpr

     [[https://github.com/ilya-babanov/emacs-bpr][source & doc]]

     Stands for Background Process Runner.
     Allows running a command process in the background.

     Allows advanced callback behaviours.

     It relies on =start-process-shell-command=.


**** pfuture

     [[https://github.com/Alexander-Miller/pfuture][source & doc]]

     Allows running a command process in the background.

     Result can be handled either with a future (=pfuture-new=, =pfuture-result=) or a callback (=pfuture-callback=).

     It relies on =make-pipe-process= for the future-based implementation and =make-process= for the callback one.


*** Async interpreter command sub-processes

    Emacs provides a layer on top of =make-process= for spawning commands from a shell interpreter (i.e. =bash= or =zsh=).

    These are provided by =simple.el= ([[https://github.com/emacs-mirror/emacs/blob/master/lisp/simple.el][source]]).

    The async version of these command is =async-shell-command=.

    Some advanced behaviours are hard to program, that's why wrapper libraries can help you.


**** friendly-shell-command

     [[https://github.com/p3r7/friendly-shell][source & doc]]

     =friendly-shell-command= provides =friendly-shell-command-async=, a wrapper around =async-shell-command= with easier access to advanced behaviours thanks to optional keyword arguments.

     It notably eases associating a callback to the end of the execution.


** Buffer Manipulation

**** b

     [[https://github.com/emacs-php/b.el][source & doc]]

     Utility functions for buffer manipulation.


**** tp

     [[https://github.com/alphapapa/tp.el][source]]

     Utilities for helping with manipulating a buffer's [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Text-Properties.html][text properties]].


** Filesystem Interactions

*** f

    [[https://github.com/rejeep/f.el][source & doc]]

    *informal standard* (not bundled with Emacs, but used everywhere)

    Modern API for working with files and directories.


** Networking

*** HTTP client

    Emacs comes already with an HTTP client, =url.el=, written in pure elisp ([[https://github.com/emacs-mirror/emacs/blob/master/lisp/url/url.el][source]]), wich has a few limitations.
    It exposes functions =url-retrieve-synchronously= and =url-retrieve= (async).


**** request

     [[https://github.com/tkf/emacs-request][source & doc]]

     Supports a bunch of options exposed clearly with keyword arguments.

     If found on the system, uses the /cURL/ binary instead of =url.el=.
     Can be customized with =request-backend=.

     Advanced asynchronicity via bindings with =deferred=.


**** mb-url

     [[https://github.com/dochang/mb-url][source & doc]]

     Stands for "Multiple Backends for URL package".

     Provides API-compatible replacements to =url-retrieve= and =url-retrieve-synchronously= using /cURL/ and /HTTPie/.


**** apiwrap

     [[https://github.com/vermiculus/apiwrap.el][source & doc]]

     Macros to ease the definition of binding functions to HTTP APIs.


**** with-proxy

     [[https://github.com/twlz0ne/with-proxy.el][source & doc]]

     Wrapper for let-binding HTTP proxies.


*** HTTP server

**** simple-httpd

     [[https://github.com/skeeto/emacs-web-server][source & doc]]

     A web server written in pure elisp.


**** porthole

     [[https://github.com/jcaw/porthole][source & doc]]

     Start [[https://en.wikipedia.org/wiki/Remote_procedure_call][RPC]] servers under Emacs. These allow executing elisp remotely through HTTP.


** GUI

*** Popups

**** frog-menu

     https://github.com/clemera/frog-menu


*** Overlays

**** ov

     [[https://github.com/emacsorphanage/ov][source & doc]]

     Helpers to manipulate overlays.
     Originally authored by [[https://github.com/ShingoFukuyama][@ShingoFukuyama]]. Unmaintained.


*** Charts & diagrams

**** chart

     [[https://francismurillo.github.io/2017-04-15-Exploring-Emacs-chart-Library/][tutorial]]

     *standard* (bundled with every Emacs install)


* Development Tools

  By default, Emacs is already pretty well set up for elisp development.

  But some features can be hard to learn and some stuff can be improved with additinal packages.

  See also those talks [[https://github.com/p3r7/awesome-elisp#john-wiegley-jwiegley][John Wiegley]] gave about hist setup for elisp development:
  - [[https://www.youtube.com/watch?v=QFClYrhV1z4][Emacs Lisp Development - @ Emacs Conference 2013]]
  - [[https://sachachua.com/blog/2015/04/2015-04-08-emacs-lisp-development-tips-with-john-wiegley/][Emacs Lisp Development Tips - Sacha Chua Emacs Chat 2015-04-08]].


** Interactive Development & Debugging

   Emacs is built with interactive development in mind.

   You could spend days developing elisp code without ever having to restart Emacs.

   Standard /commands/ used are:
   - =eval-last-sexp= (=C-x C-e=)
   - =eval-defun= (=C-M-x=)
   - =eval-buffer=
   - =eval-region=

   The =*scratch*= buffer also provides a temporary zone to try and test ideas.
   In it can be used =eval-print-last-sexp= (=C-j=) which acts like =eval-last-sexp= but also prints the result after the /s-exp/ in the buffer.

   =eval-expression= (=M-:=) allows quickly evaluating a /s-exp/ from anywhere by entering it in the /minibuffer/.

   For logging, function =(message "<text>")= allows printing into the =*Messages*= buffer.

   For debugging, the most basic command is =toggle-debug-on-error= to get a stacktrace.

   See also:
   - [[https://www.masteringemacs.org/article/evaluating-elisp-emacs][Mastering Emacs - Evaluating Elisp in Emacs]]


**** IELM

     *standard* (bundled with every Emacs install)

     Stands for Inferior Emacs Lisp Mode.

     Provides a [[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop][REPL]] for evaluating elisp code.


**** edebug

     [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/edebug.el][source]], [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html][doc]]

     *standard* (bundled with every Emacs install)

     edebug is the interactive elisp debugger.

     The documentation is a bit rough to get started.
     I recommend reading this series of posts:
     - [[https://endlessparentheses.com/debugging-emacs-lisp-part-1-earn-your-independence.html][Endless Parentheses - Debugging Elisp Part 1: Earn your independence]]
     - [[https://endlessparentheses.com/debugging-emacs-lisp-part-1-earn-your-independence.html][Endless Parentheses - Debugging Elisp Part 2: Advanced topics]]

     You can also read the dedicated [[https://www.gnu.org/software/emacs/manual/html_node/eintr/Debugging.html][chapter in book An Introduction to Programming in Emacs Lisp]].


**** macrostep

     [[https://github.com/joddie/macrostep][source & doc]]

     Interactive macro expander.

     Expand nested macros one by one.

     Way better than using default =macroexpand=.


**** eval-expr

     [[https://github.com/jwiegley/eval-expr][source]]

     Provides =eval-expr=, an enhanced =eval-expression= command.

     Some highlights:
     - automatic display of output in temp buffer if too big
     - allows pretty printing of results (with =pp=)
     - invalid /s-expr/ don't have to be retyped on 2nd try


**** eval-sexp-fu

     [[https://github.com/emacsmirror/eval-sexp-fu][source]]

     Visual improvment.

     Flashes the sexps during the evaluation.


** Documentation

   To get the documentation of a symbol, you could use one of the built-in:
   - =describe-symbol=: get documentation of symbol
   - =describe-function=: get documentation of function
   - =describe-variable=: get documentation of variable
   - =describe-key=: get documentation of /command/ associated with keybinding

   These would spawn a =*Help*= buffer. Hence documentation in Emacs is often reffered to as the /help/.

   Some packages improve on these.


*** helpful

    [[https://github.com/Wilfred/helpful][source & doc]]

    Provides more contextual information.

    | helpful command     | default command     | comment                                                            |
    |---------------------+---------------------+--------------------------------------------------------------------|
    | =helpful-at-point=  | =describe-symbol=   |                                                                    |
    | =helpful-callable=  | no equivalent       | like =helpful-function= but also works on macros and special forms |
    | =helpful-function=  | =describe-function= |                                                                    |
    | =helpful-macro=     | no equivalent       |                                                                    |
    | =helpful-variable=  | =describe-variable= |                                                                    |
    | =helpful-key=       | =describe-key=      |                                                                    |


*** which-key

    [[https://github.com/justbur/emacs-which-key][source & doc]]

    =which-key= is like an always-on =describe-key=.

    It displays automatically all the possible keybindings following a key prefix.


** Code Navigation

   To jump to the definition of a symbol Emacs provides =xref-find-definitions=. In practice it works with nicely with functions but is kind of hit-or-miss with variables.

   In addition, the following more specialised functions exist:
   - =find-function=: go to the definition of function
   - =find-variable=: go to the definition of function
   - =find-library=: go to the definition of /feature/ (i.e. module, package)

   Better options exists so that you don't have to remember all of these.

   To get the documentation of a symbol, you can use one of the default

   Honorable mention: [[https://github.com/purcell/elisp-slime-nav][elisp-slime-nav]], that can be seen as an ancestor to =elisp-def=.


*** elisp-def

    [[https://github.com/Wilfred/elisp-def][source & doc]]

    Provides =elisp-def= that allows jumping to the definition of function / variable / feature.

    Like a better =xref-find-definitions=.

    Is able to distinguish between functions / variables / features depending on the context.

    Also handles macros, functions defined through macros and let-bound variables.


** Validation

**** melpazoid

     https://github.com/riscy/melpazoid


**** elisp-lint

     https://github.com/gonewest818/elisp-lint


** Syntax highlighting

   Several packages allow to improve default syntax highlighting (/font locking/ in Emacs lingo).

   All those listed bellow are complementary.

   Honorable mention: [[https://github.com/Fanael/highlight-defined][highlight-defined]] which is ok but superseded by =lisp-extra-font-lock= functionalities.


*** lisp-extra-font-lock

    [[https://github.com/Lindydancer/lisp-extra-font-lock][source & doc]]

    Various additional syntax highlightings.

    Killer feature is having different faces for /special/ vars (global) VS /normal/ ones (local).


*** cl-lib-highlight

    [[https://github.com/skeeto/cl-lib-highlight][source & doc]]

    Provides additonal / alternative font-locking for =cl-lib= symbols, to make them stand out in your code.

    Also highlights deprecated =cl= symbols with a different face. Useful when reading legacy code.


** Pretty printing

**** pp

     [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/pp.el][source]]

     *standard* (bundled with every Emacs install)

     Standard Emacs pretty-printing util.


**** ppp

     [[https://github.com/conao3/ppp.el][source & doc]]

     Advanced pretty-printing utils.


** Building

**** cask

     https://github.com/cask/cask


**** eldev

     https://github.com/doublep/eldev


* Heroes

  Emacs has too many heroes to really list.

  In this section, we list some users who have significantly contributed with libraries and resources that improve the Emacs development experience.

  They are listed in alphabetical order.

  Another complementary list is [[https://github.com/tarsius/elisp-maintainers][elisp-maintainers]].


** @alphapapa

   [[https://github.com/alphapapa][github]]

   Contributed to elisp development with:
   - [[https://github.com/alphapapa/emacs-package-dev-handbook][The Emacs Package Developer’s Handbook]]
   - =ts=
   - =org-ql=


** Bozhidar Batsov (@bbatsov)

   [[https://github.com/bbatsov][github]], [[https://emacsredux.com/][Emacs-related blog]], [[https://github.com/sponsors/bbatsov][open to sponsoring]]

   Known for:
   - [[https://github.com/bbatsov/projectile][projectile]]: the best project management package for Emacs
   - [[https://cider.mx/][CIDER]]: the interactive Clojure development environment for Emacs

   Contributed to elisp development with:
   - [[https://github.com/bbatsov/emacs-lisp-style-guide][The Emacs Lisp Style Guide]]


** Caio Rordrigues (@caiorss)

   [[https://github.com/caiorss][github]]

   Contributed to elisp development with:
   - his book [[http://caiorss.github.io/Emacs-Elisp-Programming/][Emacs In a Box]]


** Chris Wellons (@skeeto)

   [[https://github.com/skeeto][github]], [[https://nullprogram.com/][blog]]

   Known for:
   - [[https://github.com/skeeto/elfeed][elfeed]], the popular Emacs RSS reader
   - [[https://github.com/skeeto/skewer-mode][skewer-mode]], interactive web development with auto-reload on edit

   Contributed to elisp development with:
   - his blog, /nullprogram.com/
   - [[https://github.com/skeeto/emacs-web-server][simple-httpd]]
   - =aio=
   - =week-ref=


** John Wiegley (@jwiegley)

   [[http://newartisans.com/][blog]], [[https://github.com/jwiegley][github]], [[https://github.com/jwiegley/dot-emacs/blob/master/init.el][dot emacs]]

   Known for:
   - being the head of the Emacs project maintainers
   - authoring =use-pacakge=

   Contributed to elisp development with:
   - =async.el=
   - talks on how to setup Emacs to ease elisp development:
     - [[https://www.youtube.com/watch?v=QFClYrhV1z4][Emacs Lisp Development - @ Emacs Conference 2013]]
     - [[https://sachachua.com/blog/2015/04/2015-04-08-emacs-lisp-development-tips-with-john-wiegley/][Emacs Lisp Development Tips - Sacha Chua Emacs Chat 2015-04-08]].


** Jonas Bernoulli (@tarsius)

   [[https://emacsair.me/][blog]], [[https://github.com/tarsius][github]], [[https://magit.vc/donate/][open to sponsoring]]

   Known for:
   - authoring [[https://github.com/magit/magit][magit]]
   - lots of high quality smaller packages ([[https://github.com/tarsius/orglink][orglink]], [[https://github.com/tarsius/keycast][keycast]]...)

   Contributed to elisp development with:
   - [[https://github.com/magit/transient][transient]]


** Magnar Sveen (@magnars)

   [[https://github.com/magnars][github]], [[http://twitter.com/magnars][twitter]]

   Contributed to elisp development with:
   - [[https://github.com/magnars/s.el][s]] (strings)
   - [[https://github.com/magnars/dash.el][dash]] (lists)


** Nicolas Petton

   [[https://github.com/NicolasPetton][github]]

   Known for:
   - creating the popular [[https://github.com/NicolasPetton/Indium][Indium]] interactive Javascript development environment

   Contributed to elisp development with:
   - creating the now standard =seq.el= and =map.el=
   - =stream.el=


** Oleh Krehel (@abo-abo)

   [[https://oremacs.com/][blog]], [[https://github.com/abo-abo][github]], [[https://github.com/sponsors/abo-abo][open to sponsoring]]

   Author of many high-quality packages such as [[https://github.com/abo-abo/swiper][ivy]], [[https://github.com/abo-abo/hydra][hydra]], [[https://github.com/abo-abo/lispy][lispy]]...


** Toby 'qubit' Cubitt

   [[http://www.dr-qubit.org/][website]]

   Known for:
   - [[http://www.dr-qubit.org/undo-tree/undo-tree.el][undo-tree]]

   Contributed to elisp development with [[http://www.dr-qubit.org/emacs_data-structures.html][his implementation of basic and more complex data structures]]: =queue=, =heap=, =avl-tree=, =trie=, =dict-tree=, =tNFA=.


* License

[[https://creativecommons.org/publicdomain/zero/1.0/][https://licensebuttons.net/p/zero/1.0/88x31.png]]
